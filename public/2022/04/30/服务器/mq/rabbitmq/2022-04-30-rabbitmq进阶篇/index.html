

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/leaf_icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="leellun">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、未匹配消息最终走向1.1 未被路由的情况1void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body) throws IOException;  参数说明：  mandatory： 交换器无法根据自身的">
<meta property="og:type" content="article">
<meta property="og:title" content="rabbitmq进阶篇">
<meta property="og:url" content="https://leellun.github.io/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/index.html">
<meta property="og:site_name" content="青叶水间 - 一个IT技术文章分享博客">
<meta property="og:description" content="一、未匹配消息最终走向1.1 未被路由的情况1void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body) throws IOException;  参数说明：  mandatory： 交换器无法根据自身的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leellun.github.io/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664876862674.png">
<meta property="og:image" content="https://leellun.github.io/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664876914097.png">
<meta property="og:image" content="https://leellun.github.io/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664877205760.png">
<meta property="og:image" content="https://leellun.github.io/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664878293861.png">
<meta property="og:image" content="https://leellun.github.io/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664880714968.png">
<meta property="og:image" content="https://leellun.github.io/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664880656862.png">
<meta property="article:published_time" content="2022-04-30T11:18:02.000Z">
<meta property="article:modified_time" content="2022-10-05T04:01:52.347Z">
<meta property="article:author" content="leellun">
<meta property="article:tag" content="rabbitmq">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://leellun.github.io/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664876862674.png">
  
  
  
  <title>rabbitmq进阶篇 - 青叶水间 - 一个IT技术文章分享博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"leellun.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>青叶水间</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg-default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="rabbitmq进阶篇"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-04-30 19:18" pubdate>
          2022年4月30日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          158 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">rabbitmq进阶篇</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、未匹配消息最终走向"><a href="#一、未匹配消息最终走向" class="headerlink" title="一、未匹配消息最终走向"></a>一、未匹配消息最终走向</h1><h2 id="1-1-未被路由的情况"><a href="#1-1-未被路由的情况" class="headerlink" title="1.1 未被路由的情况"></a>1.1 未被路由的情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">basicPublish</span><span class="hljs-params">(String exchange, String routingKey, <span class="hljs-type">boolean</span> mandatory, <span class="hljs-type">boolean</span> immediate, BasicProperties props, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p><strong>mandatory：</strong></p>
<p>交换器无法根据自身的类型和路由键找到一个符合条件的队列时。</p>
<p>true：RabbitMQ 会调用 Basic.Return 命令将消息返回给生产者。</p>
<p>false：消息直接被丢弃。</p>
</li>
<li><p><strong>immediate：</strong></p>
<p>当 immediate 参数设为 true 时，如果交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时，该消息会通过 Basic .Return 返回至生产者。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建通道</span><br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;topic&quot;</span>);<br>channel.addReturnListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnListener</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleReturn</span><span class="hljs-params">(<span class="hljs-type">int</span> replyCode, String replyText, String exchange,</span><br><span class="hljs-params">            String routingKey, AMQP.BasicProperties properties,</span><br><span class="hljs-params">            <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;&lt;&lt; &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 发送消息</span><br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-literal">true</span>,<br>                     MessageProperties.PERSISTENT_TEXT_PLAIN, msg);<br></code></pre></td></tr></table></figure>

<h2 id="1-2-备份交换器（AE）"><a href="#1-2-备份交换器（AE）" class="headerlink" title="1.2 备份交换器（AE）"></a>1.2 备份交换器（AE）</h2><p>通过在声明交换器（调用 channel.exchangeDeclare 方法）的时候添加 alternate-exchange 参数来实现，也可以通过策略（ Policy）的方式实现。如果两者同时使用，则声明交换器时设置的优先级更高，会覆盖掉 Policy 的设置。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明交换器</span><br><span class="hljs-comment">// 下面交换器用作备份交换器，该交换器的所有消息均路由到 unroutedQueue 队列</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;myAe&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>,<br>        <span class="hljs-literal">true</span> , <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>) ;<br>channel.queueDeclare(<span class="hljs-string">&quot;unroutedQueue&quot;</span>, <span class="hljs-literal">true</span>,<br>        <span class="hljs-literal">false</span> , <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind(<span class="hljs-string">&quot;unroutedQueue&quot;</span>,<span class="hljs-string">&quot;myAe&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br> <br><span class="hljs-comment">// 下面交换器通过 alternate-exchange 参数设置一个备份交换器</span><br><span class="hljs-comment">// 将交换器 myAe 设置为 normalExchange 的交换器</span><br>Map&lt;String, Object&gt; exchangeArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>exchangeArgs.put(<span class="hljs-string">&quot;alternate-exchange&quot;</span>, <span class="hljs-string">&quot;myAe&quot;</span>);<br>channel.exchangeDeclare(<span class="hljs-string">&quot;normalExchange&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>,<br>        <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, exchangeArgs);<br>channel.queueDeclare(<span class="hljs-string">&quot;normalQueue&quot;</span>, <span class="hljs-literal">true</span>,<br>        <span class="hljs-literal">false</span> , <span class="hljs-literal">false</span> , <span class="hljs-literal">null</span>);<br>channel.queueBind(<span class="hljs-string">&quot;normalQueue&quot;</span>, <span class="hljs-string">&quot;normalExchange&quot;</span>, <span class="hljs-string">&quot;normalKey&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>步骤说明：</p>
<p>1 申明备份交换器</p>
<p>申请一个交换器myAe和队列unroutedQueue，然后绑定myAe和unroutedQueue  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(<span class="hljs-string">&quot;myAe&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>,<br>        <span class="hljs-literal">true</span> , <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>) ;<br>channel.queueDeclare(<span class="hljs-string">&quot;unroutedQueue&quot;</span>, <span class="hljs-literal">true</span>,<br>        <span class="hljs-literal">false</span> , <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind(<span class="hljs-string">&quot;unroutedQueue&quot;</span>,<span class="hljs-string">&quot;myAe&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>2 申请一个交换器normalExchange和队列normalQueue，通过alternate-exchange指定备份交换器myAe，然后绑定normalExchange和normalQueue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; exchangeArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>exchangeArgs.put(<span class="hljs-string">&quot;alternate-exchange&quot;</span>, <span class="hljs-string">&quot;myAe&quot;</span>);<br>channel.exchangeDeclare(<span class="hljs-string">&quot;normalExchange&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>,<br>        <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, exchangeArgs);<br>channel.queueDeclare(<span class="hljs-string">&quot;normalQueue&quot;</span>, <span class="hljs-literal">true</span>,<br>        <span class="hljs-literal">false</span> , <span class="hljs-literal">false</span> , <span class="hljs-literal">null</span>);<br>channel.queueBind(<span class="hljs-string">&quot;normalQueue&quot;</span>, <span class="hljs-string">&quot;normalExchange&quot;</span>, <span class="hljs-string">&quot;normalKey&quot;</span>);<br></code></pre></td></tr></table></figure>

<h1 id="二、过期时间"><a href="#二、过期时间" class="headerlink" title="二、过期时间"></a>二、过期时间</h1><p>RabbitMQ 可以对消息和队列设置过期时间（TTL，全称 Time To Live）</p>
<ul>
<li>第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间。</li>
<li>第二种方法是对消息进行单独设置，每条消息的过期时间可以不同。</li>
</ul>
<p>如果同时设置队列和消息的过期时间，则消息的过期时间以两者之间过期时间较小的那个数值为准。消息在队列的生存时间一旦超过设置的过期时间值，就成为“死信”（Dead Message），消费者将无法再收到该消息。 </p>
<h2 id="2-1-设置消息TTL"><a href="#2-1-设置消息TTL" class="headerlink" title="2.1 设置消息TTL"></a>2.1 设置消息TTL</h2><h3 id="2-1-1-通过消息属性"><a href="#2-1-1-通过消息属性" class="headerlink" title="2.1.1 通过消息属性"></a>2.1.1 通过消息属性</h3><p>如果需要为每条消息单独设置过期时间， 通过往 AMQP.BasicProperties 属性中添加 expiration 属性来实现（单位：毫秒） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发送消息</span><br>AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties.Builder()<br>        .deliveryMode(<span class="hljs-number">2</span>) <span class="hljs-comment">// 持久化消息</span><br>        .expiration(<span class="hljs-string">&quot;6000&quot;</span>) <span class="hljs-comment">// 设置过期时间为 6 秒,等待 6 秒钟后消息将会自动删除。</span><br>        .build();<br> <br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>,<br>        properties, <span class="hljs-string">&quot;ttl message&quot;</span>.getBytes());<br></code></pre></td></tr></table></figure>

<h3 id="2-1-2-通过队列属性"><a href="#2-1-2-通过队列属性" class="headerlink" title="2.1.2 通过队列属性"></a>2.1.2 通过队列属性</h3><p>在声明队列的时候通过队列属性设置消息过期时间的方法是在 channel.queueDeclare() 方法中加入 x-message-ttl 参数实现，参数单位是毫秒。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明队列</span><br>Map&lt;String,Object&gt; argss =<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,Object&gt;() ;<br>argss.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">6000</span>); <span class="hljs-comment">// 设置过期时间为 6 秒</span><br>channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, argss) ;<br>channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure>

<h2 id="2-2-设置队列TTL"><a href="#2-2-设置队列TTL" class="headerlink" title="2.2 设置队列TTL"></a>2.2 设置队列TTL</h2><p>通过 channel.queueDeclare() 方法中的 x-expires 参数控制队列被自动删除前处于未使用状态的时间。未使用的意思是队列上没有任何的消费者，队列也没有被重新声明，并且在过期时间段内也未调用过 Basic.Get 命令。 </p>
<p>设置队列里的过期时间可以应用于类似 RPC 方式的回复队列。在 RPC 中，许多队列会被创建出来，但是却是未被使用的。</p>
<p>RabbitMQ 会确保在过期时间到达后将队列删除，但是不能保证队列会被及时删除。在 RabbitMQ 重启后，持久化的队列的过期时间会被重新计算。</p>
<p>x-expires 参数以毫秒为单位，不能设置为 0。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明队列</span><br>Map&lt;String,Object&gt; argss =<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,Object&gt;() ;<br>argss.put(<span class="hljs-string">&quot;x-expires&quot;</span>, <span class="hljs-number">6000</span>); <span class="hljs-comment">// 设置过期时间为 6 秒</span><br>channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, argss) ;<br>channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure>

<h1 id="三、死信队列（DLX）"><a href="#三、死信队列（DLX）" class="headerlink" title="三、死信队列（DLX）"></a>三、死信队列（DLX）</h1><p>当出现路由键和绑定键不匹配，或者交换器上面没有绑定队列等导致消息无法被正确的投递，为了确保消息不会被无故的丢弃，可以将其置于一个特殊的队列中，这个队列一般称之为死信队列。</p>
<p>如果消息在一个队列中变成死信（Dead Message）之后，它将被重新发送到另一个交换器中，该交换器称为死信交换器，绑定在死信交换器上的队列就称之为死信队列。</p>
<p>死信交换器的简称为 DLX（Dead-Letter-Exchange），消息变成死信有如下几种情况：</p>
<ul>
<li>消息被拒绝（Basic.Reject/Basic.Nack），并且设置 requeue 参数为 false；</li>
<li>消息过期；</li>
<li>队列达到最大长度；</li>
<li>路由键和绑定键不匹配</li>
<li>交换器上面没有绑定队列</li>
</ul>
<p>死信交换器也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列中存在死信时 RabbitMQ 就会自动地将这个消息重新发布到设置的死信交换器，进而死信交换器将消息路由到绑定到它的队列（即死信队列）。我们可以监听这个队列中的消息、以进行相应的处理，这个特性与将消息的 TTL 设置为 0 配合使用可以弥补 immediate 参数的功能。</p>
<img src="/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664876862674.png" srcset="/img/loading.gif" lazyload class="" width="1664876862674">

<p>“D”（即持久化 durable）。其中，queueName 队列还标记了“DLX”，DLX 指的是 x-dead-letter-exchange 属性设置的死信交换器。 </p>
<p>消费者拒绝消息情况下的死信队列流程图：</p>
<img src="/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664876914097.png" srcset="/img/loading.gif" lazyload class="" width="1664876914097">

<h2 id="3-1-队列添加死信交换器"><a href="#3-1-队列添加死信交换器" class="headerlink" title="3.1 队列添加死信交换器"></a>3.1 队列添加死信交换器</h2><p>通过在队列声明方法 channel.queueDeclare() 中设置 x-dead-letter-exchange 参数来为当前队列添加死信交换器（DLX）。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明死信交换器和死信队列</span><br>channel.exchangeDeclare(exchangeDlxName, <span class="hljs-string">&quot;fanout&quot;</span>);<br>channel.queueDeclare(queueDlxName, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-comment">// 将死信队列绑定到死信交换器上</span><br>channel.queueBind(queueDlxName, exchangeDlxName, <span class="hljs-string">&quot;&quot;</span>);<br>  <br><span class="hljs-comment">// 声明普通交换器和队列</span><br>channel.exchangeDeclare(exchangeName, <span class="hljs-string">&quot;topic&quot;</span>);<br>Map&lt;String,Object&gt; queueArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br><span class="hljs-comment">// 为队列设置死信交换器</span><br>queueArgs.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, exchangeDlxName);<br>channel.queueDeclare(queueName, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, queueArgs);<br><span class="hljs-comment">// 将普通队列绑定到普通交换器</span><br>channel.queueBind(queueName, exchangeName, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure>

<h1 id="四、延迟队列"><a href="#四、延迟队列" class="headerlink" title="四、延迟队列"></a>四、延迟队列</h1><p>延迟队列顾名思义就是存放延迟消息的队列，所谓“延迟消息”是指消息被发送后，并不想让消费者立刻进行消费，而是需要等待指定的时间后，消费者才能够进行消费。 </p>
<p>延迟队列的使用场景：订单支付、定时任务等。</p>
<p>模拟延迟队列的思路：</p>
<p>消息生产者发送一个带有 TTL（过期时间）的消息到正常的交换器，且正常交换器绑定的队列没有被任何消费者订阅（也就不会被消费）。当时间超过我们为消息设置的 TTL 时间后，RabbitMQ 将会自动将过期的消息发送到队列指定的死信交换器，死信交换器将消息路由到死信队列。此时，如果有消费者订阅了死信队列，则这些消息将被消费者消费，就这样成功模拟了一个延迟队列。消息流转过程如下图： </p>
<img src="/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664877205760.png" srcset="/img/loading.gif" lazyload class="" width="1664877205760">

<p>生产者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明死信交换器和死信队列，且将两者绑定到一起</span><br>channel.exchangeDeclare(exchangeDlxName, <span class="hljs-string">&quot;fanout&quot;</span>);<br>channel.queueDeclare(queueDlxName, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind(queueDlxName, exchangeDlxName, <span class="hljs-string">&quot;&quot;</span>);<br> <br><span class="hljs-comment">// 声明普通交换器和队列，且将两者绑定到一起</span><br>channel.exchangeDeclare(exchangeName, <span class="hljs-string">&quot;topic&quot;</span>);<br>Map&lt;String,Object&gt; queueArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br><span class="hljs-comment">// 为队列设置死信交换器</span><br>queueArgs.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, exchangeDlxName);<br>channel.queueDeclare(queueName, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, queueArgs);<br>channel.queueBind(queueName, exchangeName, <span class="hljs-string">&quot;&quot;</span>);<br> <br><span class="hljs-comment">// 通过消息属性设置设置消息TTL时间</span><br>AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties.Builder()<br>        .deliveryMode(<span class="hljs-number">2</span>) <span class="hljs-comment">// 持久化消息</span><br>        .expiration(<span class="hljs-string">&quot;10000&quot;</span>) <span class="hljs-comment">// 设置 TTL=10秒</span><br>        .build();<br>        <br>channel.basicPublish(exchangeName, <span class="hljs-string">&quot;&quot;</span>, properties, message.getBytes());<br></code></pre></td></tr></table></figure>

<p>消费者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明队列</span><br><span class="hljs-comment">// 声明死信交换器和死信队列，且将两者绑定</span><br>channel.exchangeDeclare(exchangeDlxName, <span class="hljs-string">&quot;direct&quot;</span>);<br>channel.queueDeclare(queueDlxName, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind(queueDlxName, exchangeDlxName, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 消费消息</span><br>channel.basicConsume(queueDlxName, <span class="hljs-literal">false</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope,</span><br><span class="hljs-params">            AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;[Consumer] body = &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h1 id="五、优先级队列"><a href="#五、优先级队列" class="headerlink" title="五、优先级队列"></a>五、优先级队列</h1><p>优先级（priority）是一种约定，通常约定优先级高的先做/先处理，优先级低的后做/后处理。 </p>
<p>在 RabbitMQ 中，可以通过设置队列的 x-max-priority 参数来实现。 </p>
<p>生产者：</p>
<p>队列的优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明交换器</span><br>channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;topic&quot;</span>);<br><span class="hljs-comment">// 声明队列</span><br>Map&lt;String,Object&gt; argss =<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,Object&gt;() ;<br><span class="hljs-comment">// 设置队列的优先级为10</span><br>argss.put(<span class="hljs-string">&quot;x-max-priority&quot;</span>, <span class="hljs-number">10</span>);<br>channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, argss) ;<br>channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>设置发送消息的优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 为每个消息设置随机优先级，优先级位于 0~10</span><br><span class="hljs-type">int</span> <span class="hljs-variable">priority</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random()*<span class="hljs-number">11</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Priority Message priority=&quot;</span> + priority;<br><span class="hljs-comment">// 设置消息的优先级</span><br>AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">msgProps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties.Builder()<br>    .priority(priority).build();<br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>,<br>                     msgProps, message.getBytes());<br></code></pre></td></tr></table></figure>

<p>消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建信道</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br> <br><span class="hljs-comment">// 声明交换器</span><br>channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;topic&quot;</span>);<br> <br><span class="hljs-comment">// 声明队列</span><br>Map&lt;String,Object&gt; argss =<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,Object&gt;() ;<br><span class="hljs-comment">// 设置队列的优先级为10</span><br>argss.put(<span class="hljs-string">&quot;x-max-priority&quot;</span>, <span class="hljs-number">10</span>);<br>channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, argss) ;<br>channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br> <br><span class="hljs-comment">// 消费消息</span><br>System.out.println(<span class="hljs-string">&quot;[Consumer] Waiting Message...&quot;</span>);<br>channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope,</span><br><span class="hljs-params">            AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 模拟费时超过</span><br>            System.out.println(<span class="hljs-string">&quot;[Consumer] message = &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br> <br>            <span class="hljs-comment">// 手动发送ACK确认消息</span><br>            channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>最高优先级为队列设置的最大优先级（上面设置的为10），每个消息设置了随机优先级，默认最低优先级为 0。</p>
<p>上面的代码中为每个消息设置了随机优先级，默认最低优先级为 0，最高优先级为队列设置的最大优先级（上面设置的为10）。</p>
<p>优先级高的消息可以被优先消费，前提：</p>
<p>如果在消费者的消费速度大于生产者的速度且 Broker 服务中没有消息堆积的情况下，对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 服务中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。 </p>
<h1 id="六、回复队列"><a href="#六、回复队列" class="headerlink" title="六、回复队列"></a>六、回复队列</h1><p>在 RabbitMQ 中，回复队列主要用于接收 RPC 调用的响应消息。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><span class="hljs-comment">// 由 RabbitMQ 自动创建队列名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">replyQueueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br><span class="hljs-comment">// 消息唯一标识，消费的时候需要进行对别</span><br><span class="hljs-type">String</span> <span class="hljs-variable">corrId</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br><span class="hljs-comment">// 通过属性设置回复队列</span><br>AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties.Builder()<br>        .correlationId(corrId)<br>        .replyTo(replyQueueName)<br>        .build();<br><span class="hljs-comment">// 发送一个消息</span><br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, RPC_QUEUE_NAME, props, message.getBytes());<br><br></code></pre></td></tr></table></figure>

<p>生产者（RPC客户端）和一个消费者（RPC服务端），生产者向一个普通的队列发送一条消息（该消息需要设置一个回复队列，通过 replyTo() 进行设置，以及一个消息唯一标识符 correlationId），消费者订阅该队列。</p>
<p>当消费者收到消息时，进行业务处理，业务处理完成后，将处理结果和收到消息的唯一标识符一并打包发送到回复队列（回复队列从收到消息的 replyTo 中获取），这条消息可以称为响应消息。然后，生产者从回复队列中接收响应消息，并根据消息唯一标识符进行处理。整个过程如下图： </p>
<img src="/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664878293861.png" srcset="/img/loading.gif" lazyload class="" width="1664878293861">

<p>消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.queueDeclare(RPC_QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>) ;<br><span class="hljs-comment">// 指该消费者在接收到队列里的消息但没有返回确认结果之前,队列不会将新的消息分发给该消费者。</span><br><span class="hljs-comment">// 队列中没有被消费的消息不会被删除，还是存在于队列中</span><br>channel.basicQos(<span class="hljs-number">1</span>) ;<br> <br>System.out.println(<span class="hljs-string">&quot;[RpcServer] Awaiting RPC requests&quot;</span>);<br>channel.basicConsume(RPC_QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope,</span><br><span class="hljs-params">            AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(message);<br>            System.out.println(<span class="hljs-string">&quot;[RpcServer] fib(&quot;</span> + message + <span class="hljs-string">&quot;)&quot;</span>);<br>            <span class="hljs-comment">// 计算斐波那契数列</span><br>            <span class="hljs-comment">// 调用业务方法</span><br>            response += fib(n);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;[RpcServer] &quot;</span> + e.toString());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 回复消息属性</span><br>            AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">replyProps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties.Builder()<br>                    <span class="hljs-comment">// 消息的唯一标识回传</span><br>                    .correlationId(properties.getCorrelationId())<br>                    .build();<br>            <span class="hljs-comment">// 将响应消息写入到回复队列，回复队列有客户端通过 replyTo 指定</span><br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, properties.getReplyTo(),<br>                    replyProps, response.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>            <span class="hljs-comment">// 手动确认消息</span><br>            channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发送消息给RPC服务端</span><br><span class="hljs-type">String</span> <span class="hljs-variable">corrId</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties.Builder()<br>        .correlationId(corrId)<br>        .replyTo(replyQueueName)<br>        .build();<br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, RPC_QUEUE_NAME, props, message.getBytes());<br> <br><span class="hljs-comment">// 等待接收服务端响应</span><br>String response;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    QueueingConsumer.Delivery delivery= consumer.nextDelivery();<br>    <span class="hljs-keyword">if</span>(delivery.getProperties().getCorrelationId().equals(corrId)) &#123;<br>        response = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>#七、持久化</p>
<p>持久化（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 </p>
<p>持久化可以提高 RabbitMQ 的可靠性，以防止在异常情况（重启、关闭、宿机等）下的数据丢失。RabbitMQ 的持久化分为三个部分：交换器持久化、队列持久化和消息持久化 </p>
<h2 id="7-1-交换器（Exchange）持久化"><a href="#7-1-交换器（Exchange）持久化" class="headerlink" title="7.1 交换器（Exchange）持久化"></a>7.1 交换器（Exchange）持久化</h2><p> exchangeDeclare() 中的 durable 参数置为 true 实现的 ，将交换器信息存储到磁盘，重启 RabbitMQ 服务后交换器信息不会丢失。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Exchange.DeclareOk <span class="hljs-title function_">exchangeDeclare</span><span class="hljs-params">(String exchange, String type, <span class="hljs-type">boolean</span> durable, <span class="hljs-type">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure>

<p>如果设置为 false，则不开启持久化功能，那么在 RabbitMQ 服务重启之后，相关的交换器元数据会丢失，不过消息不会丢失。只是不能将新的消息发送到该交换器中了。如果需要长期使用的交换器，建议将其设置为持久化。 </p>
<h2 id="7-2-队列（Queue）持久化"><a href="#7-2-队列（Queue）持久化" class="headerlink" title="7.2 队列（Queue）持久化"></a>7.2 队列（Queue）持久化</h2><p>队列的持久化是通过将声明队列方法 queueDeclare() 中的 durable 参数置为 true 实现的，队列开启持久化功能 . 队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。 </p>
<p>如果设置为 false，则队列不开启持久化功能。那么在 RabbitMQ 服务重启之后，队列相关的元数据会丢失，存储在队列中的消息也会丢失。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue.DeclareOk <span class="hljs-title function_">queueDeclare</span><span class="hljs-params">(String queue, <span class="hljs-type">boolean</span> durable , <span class="hljs-type">boolean</span> exclusive,  <span class="hljs-type">boolean</span> autoDelete , Map&lt;String, Object&gt; arguments)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure>

<h2 id="7-3-消息（Message）持久化"><a href="#7-3-消息（Message）持久化" class="headerlink" title="7.3 消息（Message）持久化"></a>7.3 消息（Message）持久化</h2><p>消息持久化可以通过将消息的投递模式 (BasicProperties 中的 deliveryMode 属性）设置为 2 即可实现消息的持久化。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BasicProperties</span> <span class="hljs-variable">PERSISTENT_TEXT_PLAIN</span> <span class="hljs-operator">=</span><br>	<span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicProperties</span>(<span class="hljs-string">&quot;text/plain&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-comment">// 发送消息</span><br>System.out.println(<span class="hljs-string">&quot;[Send] Sending Message...&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">mandatory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">byte</span>[] msg = <span class="hljs-string">&quot;hello wrold&quot;</span>.getBytes();<br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>,<br>        mandatory, MessageProperties.PERSISTENT_TEXT_PLAIN, msg);<br></code></pre></td></tr></table></figure>

<p>同时将队列和消息设置为持久化，当重启 RabbitMQ 服务后，消息依旧存在。如果仅仅将队列设置为持久化，重启之后消息会丢失；如果仅仅将消息设置为持久化，重启之后队列消失，而且消息也丢失； </p>
<h2 id="7-4-持久化分析"><a href="#7-4-持久化分析" class="headerlink" title="7.4 持久化分析"></a>7.4 持久化分析</h2><p>将交换器、队列、消息都设置了持久化之后并不能百分之百保证数据不丢失 。</p>
<p>导致数据丢失情况：</p>
<ul>
<li><p>订阅消费队列时将 autoAck（自动确认）参数设置为 true ，当消费者接收到相关消息之后，还没来得及处理就宕机了，那么这条消息就丢失了。这种情况很好解决，将 autoAck 参数设置为 false ，并进行手动确认即可。</p>
</li>
<li><p>将持久化消息发送到 RabbitMQ 服务之后，消息还没有刷到磁盘就宕机了。</p>
<p>可以引入镜像队列+slave机制来解决这个问题，但并不能完全保证消息不丢失。</p>
</li>
<li><p>最后，还可以在发送端引入事务机制或者发送方确认机制来保证消息己经正确地发送并存储至 RabbitMQ 中，前提还要保证在调用 channel.basicPublish() 方法的时候交换器能够将消息正确路由到相应的队列之中。</p>
</li>
</ul>
<h1 id="八、如何保证消息是否成功发送到mq服务器"><a href="#八、如何保证消息是否成功发送到mq服务器" class="headerlink" title="八、如何保证消息是否成功发送到mq服务器"></a>八、如何保证消息是否成功发送到mq服务器</h1><p>解决方案：</p>
<p>（1）通过事务机制实现；</p>
<p>（2）通过发送方确认（Publisher Confirm）机制实现；</p>
<h2 id="8-1-事务机制"><a href="#8-1-事务机制" class="headerlink" title="8.1 事务机制"></a>8.1 事务机制</h2><p>RabbitMQ Java 客户端中与事务机制相关的方法有三个：</p>
<ul>
<li>channel.txSelect() 用于将当前信道 Channel 设置为事务模式；</li>
<li>channel.txCommit() 用于提交事务；</li>
<li>channel.txRollback() 用于事务回滚；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 开启事务</span><br>    channel.txSelect();<br>    <span class="hljs-comment">// 发送消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;transaction message&quot;</span>;<br>    channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>, message.getBytes());<br>    System.out.println(<span class="hljs-string">&quot;[Send] Send message ‘&quot;</span> + message + <span class="hljs-string">&quot;’&quot;</span>);<br>    <span class="hljs-comment">// 提交消息</span><br>    channel.txCommit();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>    <span class="hljs-comment">// 事务回滚</span><br>    channel.txRollback();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是使用事务机制会 “吸干” RabbitMQ 的性能</p>
<img src="/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664880714968.png" srcset="/img/loading.gif" lazyload class="" width="1664880714968">

<h2 id="8-2-发送方确认机制"><a href="#8-2-发送方确认机制" class="headerlink" title="8.2 发送方确认机制"></a>8.2 发送方确认机制</h2><p>同步确认：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将信道置为 publisher confirm 模式</span><br>channel.confirmSelect();<br><span class="hljs-comment">// 发送消息</span><br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;transaction message&quot;</span>;<br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>, message.getBytes());<br>System.out.println(<span class="hljs-string">&quot;[Send] Send message ‘&quot;</span> + message + <span class="hljs-string">&quot;’&quot;</span>);<br><span class="hljs-comment">// 等待消息被确认</span><br><span class="hljs-keyword">if</span>(!channel.waitForConfirms()) &#123;<br>    System.out.println(<span class="hljs-string">&quot;[Send] Send message failed.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="/2022/04/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-30-rabbitmq%E8%BF%9B%E9%98%B6%E7%AF%87/1664880656862.png" srcset="/img/loading.gif" lazyload class="" width="1664880656862">

<p>异步确认方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加监听器</span><br>channel.addConfirmListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfirmListener</span>() &#123;<br>    <span class="hljs-comment">// 处理 Basic.Ack 命令</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleAck</span><span class="hljs-params">(<span class="hljs-type">long</span> deliveryTag, <span class="hljs-type">boolean</span> multiple)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;ConfirmListener.handleAck deliveryTag=&quot;</span> +<br>                deliveryTag + <span class="hljs-string">&quot;, multiple=&quot;</span> + multiple);<br>        <span class="hljs-keyword">if</span> (multiple) &#123;<br>            <span class="hljs-comment">// headSet() 方法将返回小于 deliveryTag - 1 的元素</span><br>            MESSAGE_LIST.headSet(deliveryTag - <span class="hljs-number">1</span>).clear();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 移除等于 deliveryTag 的元素</span><br>            MESSAGE_LIST.remove(deliveryTag);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">// 处理 Basic.Nack 命令</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleNack</span><span class="hljs-params">(<span class="hljs-type">long</span> deliveryTag, <span class="hljs-type">boolean</span> multiple)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;ConfirmListener.handleNack deliveryTag=&quot;</span> +<br>                deliveryTag + <span class="hljs-string">&quot;, multiple=&quot;</span> + multiple);<br>        <span class="hljs-keyword">if</span> (multiple) &#123;<br>            MESSAGE_LIST.headSet(deliveryTag - <span class="hljs-number">1</span>).clear();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            MESSAGE_LIST.remove(deliveryTag);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h1 id="九、消息分发"><a href="#九、消息分发" class="headerlink" title="九、消息分发"></a>九、消息分发</h1><p>当 RabbitMQ 服务器的队列拥有多个消费者时，队列收到的消息将以轮询（round-robin）的方式分发给消费者。 </p>
<p>默认情况下，如果有 n 个消费者，那么 RabbitMQ 服务器会将第 m 条消息分发给第 m%n（取余的方式）个消费者，RabbitMQ 服务器不管消费者是否消费并己经确认（Basic.Ack）了消息，到下一个轮训周期依然会发送消息给当前消费者。 </p>
<p>如果某些消费者任务繁重，来不及消费那么多的消息，而某些其他消费者由于某些原因（比如业务逻辑简单、机器性能卓越等）很快地处理完了所分配到的消息，进而进程空闲，这样就会造成整体应用吞吐量的下降，即部分机器忙的不行，部分机器闲的不行，资源没有被最大程度使用。 </p>
<p>channel.basicQos(int prefetchCount)方法，channel.basicQos() 方法允许限制信道上的消费者所能保持的最大未确认消息的数量。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">basicQos</span><span class="hljs-params">(<span class="hljs-type">int</span> prefetchCount)</span> <span class="hljs-keyword">throws</span> IOException;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">basicQos</span><span class="hljs-params">(<span class="hljs-type">int</span> prefetchCount, <span class="hljs-type">boolean</span> global)</span> <span class="hljs-keyword">throws</span> IOException;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">basicQos</span><span class="hljs-params">(<span class="hljs-type">int</span> prefetchSize, <span class="hljs-type">int</span> prefetchCount, <span class="hljs-type">boolean</span> global)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>prefetchSize：</strong>未确认消息的总体大小的上限（单位：B，0则表示没有上限。</p>
</li>
<li><p><strong>prefetchCount：</strong>最大未确认消息的数量， 0表示没有上限。</p>
<p><strong>注意：</strong>对于一个信道来说，它可以同时消费多个队列，当设置了 prefetchCount 大于 1 时，这个信道需要和各个队列协调以确保发送的消息都没有超过所限定的 prefetchCount 的值，这样会降低 RabbitMQ 的性能，尤其是这些队列分散在集群中的多个 Broker 节点之中。</p>
</li>
<li><p><strong>global：</strong>RabbitMQ 为了提升相关的性能（例如：同一个信道消费多个队列时，且 prefetchCount 参数大于 1），在 AMQP0-9-1 协议之上重新定义了 global 这个参数。取值如下：</p>
</li>
<li><ul>
<li>true：所有的消费者都要遵从 prefetchCount 的限定值；</li>
<li>false：信道上新的消费者才需要遵从 prefetchCount 参数的限定；</li>
</ul>
</li>
</ul>
<h1 id="十、消息传输可靠性"><a href="#十、消息传输可靠性" class="headerlink" title="十、消息传输可靠性"></a>十、消息传输可靠性</h1><ul>
<li>消费者确认</li>
<li>生产者确认</li>
<li>mandatory标志说明开启了消息故障检测模式，只会让RabbitMq向你通知失败，而不会通知成功。 或者通过备份交换器来确保消息能够从交换器路由到队列中，进而能够保存下来而不会被丢弃。 </li>
<li>消息和队列都需要进行持久化处理 </li>
</ul>
<h1 id="十一、RabbitMQ-可靠性、重复消费、顺序性、消息积压解决方案"><a href="#十一、RabbitMQ-可靠性、重复消费、顺序性、消息积压解决方案" class="headerlink" title="十一、RabbitMQ 可靠性、重复消费、顺序性、消息积压解决方案"></a>十一、RabbitMQ 可靠性、重复消费、顺序性、消息积压解决方案</h1><p>1 消息确认机制、消息未路由机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enableConfirmCallback</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//ack true:当消息成功发到交换机 false:没有发送到交换机 </span><br>        <span class="hljs-comment">//correlationData:可在发送时指定消息唯一 id</span><br>        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(!ack)&#123;<br>                <span class="hljs-comment">//记录日志、发送邮件通知、落库定时任务扫描重发</span><br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-comment">//当消息成功发送到交换机没有路由到队列触发此监听</span><br>        rabbitTemplate.setReturnsCallback(returned -&gt; &#123;<br>            <span class="hljs-comment">//记录日志、发送邮件通知、落库定时任务扫描重发</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于消息未路由到消息队列可以通过设置alternate-exchange备份交换机交给rabbitmq去做可靠性</p>
<p>2 可靠性保障</p>
<ul>
<li>为了防止rabbitmq 宕机或者重启弄丢消息，加入持久化</li>
<li>创建镜像队列做高可用机制</li>
<li>消费者手动应答（ack）机制 </li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span> <span class="hljs-comment">#手动应答</span><br></code></pre></td></tr></table></figure>

<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">channel.basicNack(deliveryTag, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<span class="hljs-regexp">//</span>容易出现问题，不管第三个参数<span class="hljs-literal">true</span>还是<span class="hljs-literal">false</span>，<span class="hljs-literal">true</span>表示重新回到队列顶部，<span class="hljs-literal">false</span>表示抛弃<br></code></pre></td></tr></table></figure>

<p>真实的场景一般是三种选择</p>
<ul>
<li><strong>当消费失败后将此消息存到 Redis，记录消费次数，如果消费了三次还是失败，就丢弃掉消息，记录日志落库保存</strong></li>
<li><strong>直接填 false ，不重回队列，记录日志、发送邮件等待开发手动处理</strong></li>
<li><strong>不启用手动 ack ，使用 SpringBoot 提供的消息重试</strong></li>
</ul>
<p> springboot消息解决方式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">retry:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment">#重试次数</span><br></code></pre></td></tr></table></figure>

<p>3 消息重复消费（幂等性）</p>
<p>(1)确保消费端只执行一次</p>
<p>通过redis设置状态，比如订单：redis.set(“order”+订单id)</p>
<p>(2)允许消费端执行多次，保证数据不受影响 </p>
<ul>
<li>数据库唯一键约束 </li>
<li>数据库乐观锁思想 </li>
</ul>
<p>4 顺序性</p>
<p>顺序消费的业务，我们可以只部署一个消费者实例，然后设置 RabbitMQ 每次只推送一个消息 </p>
<h1 id="十二、-消息（堆积）积压"><a href="#十二、-消息（堆积）积压" class="headerlink" title="十二、 消息（堆积）积压"></a>十二、 消息（堆积）积压</h1><p>可能消费者突然挂了我们没有发现，可能消费者处理消费能力出现问题，与生产者产生消息速度不匹配。 </p>
<p>问题：</p>
<ul>
<li>消息存留时间过长，导致失效消失；</li>
<li>消息队列集群磁盘被写满；</li>
<li>长时间挤压，哪怕是消费者恢复了消费速度还是要很久才能慢慢消费完</li>
</ul>
<p>解决方式：</p>
<p>1、申请资源新建一个topic增加partition分区，比如原来是3个，那我们就增加到30个，并且建立30个消费者去同时消费，那速度自然就增加了10倍。原来的3个就需要将原本的数据也写入新的topic中。等到积压消息处理完了，再改回原本的消费者中。</p>
<p>2、如果用了rabbitMQ，并且设置了超时时间，消息积压的时候就有可能会出现超时丢失的情况。一般情况下生产环境是不会设置超时时间的，但是万一设置了出现这种情况，我们首先是要排除问题保证后续消息处理正常，不会再造成丢失。然后等过了数据高峰期再写个临时程序，将丢失的数据一点点查询出来，重新写入topic中。</p>
<p>3、如果长时间没有消费导致磁盘满了怎么办，如果不能临时扩容，那么只有两种方案，要么将消息扔掉等过了高峰期走上面的第二种方案，去补偿数据；要么新建立一个消费者，将消息快速消费存入一个新的地方。</p>
<h1 id="十三、延迟插件"><a href="#十三、延迟插件" class="headerlink" title="十三、延迟插件"></a>十三、延迟插件</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>下载对应版本插件<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/rabbitmq/</span>rabbitmq-delayed-message-exchange/releases<br><br>wget -c https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/rabbitmq/</span>rabbitmq-delayed-message-exchange<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v3.8.0/</span>rabbitmq_delayed_message_exchange-<span class="hljs-number">3.8</span>.<span class="hljs-number">0</span>.ez<br>cp rabbitmq_delayed_message_exchange-<span class="hljs-number">3.8</span>.<span class="hljs-number">0</span>.ez  <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/rabbitmq/</span>plugins/.<br><span class="hljs-comment">#启用插件</span><br>rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br><span class="hljs-comment">#查看插件列表</span><br>rabbitmq-plugins list<br></code></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>arguments.put(<span class="hljs-string">&quot;x-delayed-type&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<br><span class="hljs-comment">// 声明普通交换器和队列</span><br>channel.exchangeDeclare(exchangeName, <span class="hljs-string">&quot;x-delayed-message&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, arguments);<br>channel.queueDeclare(queueName, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind(queueName, exchangeName, <span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-comment">// 发送带有TTL过期时间的消息</span><br>System.out.println(<span class="hljs-string">&quot;[Sender] Send Message...&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;exchange delay message&quot;</span>;<br>Map&lt;String, Object&gt; headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>headers.put(<span class="hljs-string">&quot;x-delay&quot;</span>, <span class="hljs-number">5000</span>);<br>AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties.Builder()<br>    .headers(headers)<br>    .build();<br>channel.basicPublish(exchangeName, <span class="hljs-string">&quot;&quot;</span>, properties, message.getBytes());<br></code></pre></td></tr></table></figure>

<h1 id="十四、镜像队列"><a href="#十四、镜像队列" class="headerlink" title="十四、镜像队列"></a>十四、镜像队列</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">rabbitmqctl <span class="hljs-keyword">set</span>_policy <span class="hljs-params">--priority</span> 0 <span class="hljs-params">--apply-to</span> queues mirror_queue <span class="hljs-string">&quot;^mirror_&quot;</span> &#x27;&#123;<span class="hljs-string">&quot;ha-mode&quot;</span>:<span class="hljs-string">&quot;exactly&quot;</span>,<span class="hljs-string">&quot;ha-params&quot;</span><span class="hljs-function">:3</span>,<span class="hljs-string">&quot;ha-sync-mode&quot;</span>:<span class="hljs-string">&quot;automatic&quot;</span>&#125;&#x27;<br></code></pre></td></tr></table></figure>

<p>说明：添加镜像队列mirror_queue，匹配规则为”mirror_”开头队列，匹配到队列，规则为exactly指定代理生成ha-params=3的个数上生成镜像，并且ha-sync-mode为异步</p>
<p>通过界面添加镜像队列：</p>






<h1 id="源码分享："><a href="#源码分享：" class="headerlink" title="源码分享："></a>源码分享：</h1><p><a target="_blank" rel="noopener" href="https://github.com/leelun/rabbitmq-learn">https://github.com/leelun/rabbitmq-learn</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="category-chain-item">服务器</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/" class="category-chain-item">mq</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/rabbitmq/">#rabbitmq</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>rabbitmq进阶篇</div>
      <div>https://leellun.github.io/2022/04/30/服务器/mq/rabbitmq/2022-04-30-rabbitmq进阶篇/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>leellun</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年4月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/07/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/2022-05-07-rabbitmq%E3%80%81kafka%E3%80%81activemq%E3%80%81rocketmq%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94/" title="rabbitmq、kafka、activemq、rocketmq选型对比">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">rabbitmq、kafka、activemq、rocketmq选型对比</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/22/%E6%9C%8D%E5%8A%A1%E5%99%A8/mq/rabbitmq/2022-04-22-rabbitmq%E4%BC%AA%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" title="rabbitmq伪集群搭建">
                        <span class="hidden-mobile">rabbitmq伪集群搭建</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/leellun" target="_blank" rel="nofollow noopener"><span>我的github</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
