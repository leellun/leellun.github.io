---
title: 多线程执行一定比串行执行快吗？
date: 2023-03-04 20:18:54
categories:
  - 后端
  - java
tags:
  - 并发编程 
---

## 1 并发编程

将串行执行部分变成并发执行，但要考虑上下文切换和资源调度的时间

并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。

## 2 多线程程序的评量标准

- 安全性——不损坏对象

  对象损坏指对象的状态不符合设计师的设计原意，通常是对象的字段所取得的值和预期不一样。 

- 生存性——进行必要的处理

  最典型的例子就是死锁 

- 复用性——可再利用类

  类的复用性，在写多线程程序的时候，如果能巧妙地将线程共享结构隐藏在类里，这就是一个具有高度复用性的程序。 

- 性能——能快速、大量进行处理

## 3 影响多线程的因素

多线程执行不一定比串行执行快。

影响多线程运行速度的原因有**上下文切换**、**死锁**，以及**硬件和软件的资源限制**等；

### 3.1 上下文切换

即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。

CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。

上下文切换也会影响多线程的执行速度

```java
public class ConcurrencyTest {

	/** 执行次数 */
	private static final long count = 10000l;

	public static void main(String[] args) throws InterruptedException {
		// 并发计算
		concurrency();
		// 单线程计算
		serial();
	}

	private static void concurrency() throws InterruptedException {
		long start = System.currentTimeMillis();
		Thread thread = new Thread(new Runnable() {
			@Override
			public void run() {
				int a = 0;
				for (long i = 0; i < count; i++) {
					a += 5;
				}
				System.out.println(a);
			}
		});
		thread.start();
		int b = 0;
		for (long i = 0; i < count; i++) {
			b--;
		}
		thread.join();
		long time = System.currentTimeMillis() - start;
		System.out.println("并发:" + time + "ms,b=" + b);
	}

	private static void serial() {
		long start = System.currentTimeMillis();
		int a = 0;
		for (long i = 0; i < count; i++) {
			a += 5;
		}
		int b = 0;
		for (long i = 0; i < count; i++) {
			b--;
		}
		long time = System.currentTimeMillis() - start;
		System.out.println("串行:" + time + "ms,b=" + b + ",a=" + a);
	}

}
```

执行结果：

```
50000
并发:2ms,b=-10000
串行:0ms,b=-10000,a=50000
```

执行相同的任務，对于耗时不大的任務进行拆分多线程执行，可能会适得其反。

创建线程使用是直接向系统申请资源的，对操作系统来说,创建一个线程的代价是十分昂贵的, 需要给它分配内存、列入调度,同时在线程切换的时候还要执行内存换页,CPU 的缓存被清空,切换回来的时候还要重新从内存中读取信息,破坏了数据的局部性。

### 3.2 死锁

两个线程分别获取了锁定，互相等待另一线程解除锁定的现象。发生死锁时，哪个线程都不能执行下去，所以程序就失去了生命性。

避免一个线程同时获取多个锁，避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

例如：

代码块一：

```java
synchronized (B) {
	//1
     synchronized (A) {
               //.........
     }
}
```

代码块二：

```java
synchronized (A) {
     //2
     synchronized (B) {
               //.........
     }
}
```

当线程甲到达1时，线程乙到达2时，两个线程将进入互相等待对方释放对象锁。

### 3.3 资源限制

硬件资源和软件资源

### 3.4 硬件资源

如宽带 硬盘读写 内存 cpu处理速度 

### 3.5 软件资源

如数据库连接数、socket连接数等

## 4 优化多线程

可以通过调优减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。因为多线程竞争锁时，会引起上下文切换。

协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

