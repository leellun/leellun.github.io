---
title: redis常见使用场景
date: 2022-09-27 20:14:02
categories:
  - 应用场景
  - redis
tags:
  - redis  
---

## 1、数据缓存

```java
@Bean
@SuppressWarnings("all")
public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
    RedisTemplate<String, Object> template = new RedisTemplate<String, Object>();
    template.setConnectionFactory(factory);
    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
    ObjectMapper om = new ObjectMapper();
    om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
    om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
    jackson2JsonRedisSerializer.setObjectMapper(om);
    StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();

    // key采用String的序列化方式
    template.setKeySerializer(stringRedisSerializer);

    // hash的key也采用String的序列化方式
    template.setHashKeySerializer(stringRedisSerializer);

    // value序列化方式采用jackson
    template.setValueSerializer(jackson2JsonRedisSerializer);

    // hash的value序列化方式采用jackson
    template.setHashValueSerializer(jackson2JsonRedisSerializer);

    template.afterPropertiesSet();
    return template;
}
```

设置序列化和反序列化，通过对key和value进行序列化存储和反序列化给应用程序。

## 2、共享session

String 类型，因为 Redis 是分布式的独立服务，可以在多个应用之间共享

```
<dependency> 
 <groupId>org.springframework.session</groupId> 
 <artifactId>spring-session-data-redis</artifactId> 
</dependency>#通过在启动类开启redissession支持
```

```
@SpringBootApplication
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 1800, flushMode = FlushMode.IMMEDIATE,redisNamespace = "mall")
public class AuthServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthServerApplication.class, args);
    }
}
```

配置redissession类

```
@Configuration
public class GulimallSessionConfig {
    //配置一个默认的序列化处理器
    @Bean
    public RedisSerializer<Object> springSessionDefaultRedisSerializer() {
        return new GenericJackson2JsonRedisSerializer();
    }
    //设置cookiename MALLSESSIONID，domain mall.com
    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer serializer = new DefaultCookieSerializer();
        serializer.setCookieName("MALLSESSIONID");
        serializer.setDomainName("mall.com");
        return serializer;
    }
}
```

注意：上面的依赖配置在每一个需要启动的服务都需要

## 3、分布式锁

分布式锁有多种方式实现：

mysql方式

需要一个mysql表作为锁表，利用mysql的键的唯一性及insert的原子性，得到同一时刻，只会有一个线程插入相同的记录

zk方式

采取zk的临时路径，推荐curator-framework

redis方式

这个redisson主要思想：通过setnx创建一个30s的key，并且创建一个守护线程10s续命分布式锁执行一次setnx，放置key因为过期造成其它线程进入访问引起业务数据异常。比较注意的是，redession加入pub/sub 消息发布订阅机制，当客户端释放锁时会pub一个消息，其它客户端收到消息，又会去竞争锁。这里运用的思想还是AQS。

非常重要：通过分布式锁，再一次说明了AQS的重要性。

## 4、全局ID

int类型，incrby，利用原子性

```
incrby userid 1000
```

分库分表的场景，一次性拿一段

## 5、计数器

int类型，incr方法

例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入Redis再定时同步到数据库。

在 Redis 的数据结构中，`string`、`hash`和`sorted set`都提供了`incr`方法用于原子性的自增操作。

- 如果应用需要显示每天的注册用户数，便可以使用string作为计数器，设定一个名为REGISTERED_COUNT_TODAY的 key，并在初始化时给它设置一个到凌晨 0 点的过期时间，每当用户注册成功后便使用incr命令使该 key 增长 1，同时当每天凌晨 0 点后，这个计数器都会因为 key 过期使值清零。
- 每条微博都有点赞数、评论数、转发数和浏览数四条属性，这时用hash进行计数会更好，将该计数器的 key 设为weibo:weibo_id，hash的 field 为like_number、comment_number、forward_number和view_number，在对应操作后通过hincrby使hash 中的 field 自增。
- 如果应用有一个发帖排行榜的功能，便选择sorted set吧，将集合的 key 设为POST_RANK。当用户发帖后，使用zincrby将该用户 id 的 score 增长 1。sorted set会重新进行排序，用户所在排行榜的位置也就会得到实时的更新。

## 6、限流

incr访问次数，当超过次数false

## 7、位统计（在线用户）

String类型的bitcount

**setbit**

`setbit key offset value`：给对应的位设置值

**getbit**

`getbit key offset` 获取指定位的值

**bitcount**

`bitcount key [start] [end]` 获取指定范围为1的个数

例如：

```
//设置用户id为3的用户在2022-5-17登录
$ setbit user:view:2022-5-17 3 1
//查看用户id为3的用户在2022-5-17是否登录
$ getbit user:view:2022-5-17 3
//查看2022-5-17有多少人登录
$ bitcount user:view:2022-5-17
```

**Bitmaps间的操作**：不过生产环境很难用上，生产环境现在大多都是集群，所以交集并集之类的用不上

```
bitop op destkey key [key ...]
```

`bitop`命令可以对多个bitmaps做交集（and)、并集（or）、非（not）、异或（xor），并将操作结果存放在`destkey`中。

```
// 将17、18、19集合结果放到three:and上
$ bitop and three:and user:view:2022-5-17 user:view:2022-5-18 user:view:2022-5-19
$ bitcount three:and
```

## 8、时间轴（Timeline）

list为双向链表。

如果将list用作时间轴，用户通过lpush发完消息，可以通过lrange拉取最新的消息。lrange可以指定需要多少length。

例如：微博消息发布后，通过lrange获取最新微博。

## 9. 消息队列

有序消息队列：Redis 中list的数据结构实现是双向链表，消息的生产者只需要通过lpush将消息放入 list，消费者便可以通过rpop取出该消息，并且可以保证消息的有序性。

优先级消息队列：带有优先级的消息队列也可以选择sorted set。

pub/sub用作发布者 / 订阅者模型的消息，不需要担心由于服务器故障导致消息丢失的情况，Redis 拥有持久化功能。

Redis 中list的数据结构实现是双向链表，所以可以非常便捷的应用于消息队列（生产者 / 消费者模型）。消息的生产者只需要通过lpush将消息放入 list，消费者便可以通过rpop取出该消息，并且可以保证消息的有序性。如果需要实现带有优先级的消息队列也可以选择sorted set。而pub/sub功能也可以用作发布者 / 订阅者模型的消息。无论使用何种方式，由于 Redis 拥有持久化功能，也不需要担心由于服务器故障导致消息丢失的情况。

List提供了两个阻塞的弹出操作：blpop/brpop，可以设置超时时间：

- blpop：blpop key1 timeout 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。
- brpop：brpop key1 timeout 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。

队列：先进先除：rpush blpop，左头右尾，右边进入队列，左边出队列
栈：先进后出：rpush brpop

## 10、抽奖

利用set结构的无序性,通过 Spop（ Redis Spop 命令用于移除集合中的指定 key 的一个或多个随机元素，移除后会返回移除的元素。 ） 随机获得值。

```
> smembers key1
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "7"
7) "8"
> spop key1
"8"
> spop key1
"3"
```

## 11、点赞、签到、打卡

```
假如上面的微博ID是t1001，用户ID是u3001

用 like:t1001 来维护 t1001 这条微博的所有点赞用户

点赞了这条微博：sadd like:t1001 u3001
取消点赞：srem like:t1001 u3001
是否点赞：sismember like:t1001 u3001
点赞的所有用户：smembers like:t1001
点赞数：scard like:t1001
```

## 12 商品标签

```
sadd tags:i5001 画面清晰细腻
sadd tags:i5001 真彩清晰显示屏
sadd tags:i5001 流程至极
```

## 13、好友关系、用户关注、推荐模型

```
A:follow：存放 A 所有关注的用户 id

A:follower：存放 A 所有粉丝的用户 id

那么通过sinter命令便可以根据A:follow和A:follower的交集得到与 A 互相关注的用户。当 A 进入另一个用户 B 的主页后，A:follow和B:follow的交集便是 A 和 B 的共同专注，A:follow和B:follower的交集便是 A 关注的人也关注了 B。
```

例如：

```
相互关注：

sadd 1:follow 2
sadd 1:follower 2
sadd 2:follower 1
sadd 2:follow 1
1关注的人也关注了他(取交集)：

交集：sinter 1:follow 2:follower

用户1可能认识的人(差集)：sdiff 2:follow 1:follow
用户2可能认识的人：sdiff 1:follow 2:follow
```

## 14 .排行榜

id 为6001 的新闻点击数加1：

```
zincrby hotNews:20190926 1 n6001
```

获取今天点击最多的15条：

```
zrevrange hotNews:20190926 0 15 withscores
```

## 15 .倒排索引

可以通过分词器把对应的分词 设置set key id，然后通过id找到对应的数据。一般用es









参考文章：

https://blog.csdn.net/agonie201218/article/details/123640871